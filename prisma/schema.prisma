// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id            String    @id @default(cuid())
  username      String?   @unique // Unique username for each user
  displayName   String?   @map("display_name") // Optional display name shown in UI
  email         String    @unique
  password      String
  image         String?
  role          String    @default("USER") // "ADMIN" or "USER"
  isActive      Boolean   @default(true) @map("is_active")
  createdAt     DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt     DateTime  @updatedAt @map("updated_at") @db.Timestamptz
  
  // Quota management
  quota         BigInt    @default(10737418240) // 10GB in bytes
  usedSpace     BigInt    @default(0) @map("used_space")

  settings      String    @default("{}") // JSON string for user settings

  emailVerified      DateTime? @map("email_verified") @db.Timestamptz
  verificationToken  String?   @map("verification_token")
  twoFactorEnabled   Boolean   @default(false) @map("two_factor_enabled")
  twoFactorSecret    String?   @map("two_factor_secret")
  
  // Password reset
  resetToken         String?   @map("reset_token")
  resetTokenExpiry   DateTime? @map("reset_token_expiry") @db.Timestamptz

  materials     Material[]
  folders       Folder[]
  wordStatuses  UserWordStatus[]
  practices     PracticeProgress[]
  dailyStats    DailyStudyStat[]
  notifications Notification[]
  learningSessions LearningSession[]

  @@map("users")
}

model Folder {
  id        String     @id @default(cuid())
  name      String
  userId    String     @map("user_id")
  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  parentId  String?    @map("parent_id")
  parent    Folder?    @relation("FolderHierarchy", fields: [parentId], references: [id])
  children  Folder[]   @relation("FolderHierarchy")
  materials Material[]
  order     Int        @default(0)
  createdAt DateTime   @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime   @updatedAt @map("updated_at") @db.Timestamptz
  deletedAt DateTime?  @map("deleted_at") @db.Timestamptz

  @@index([userId, parentId, order], name: "folders_user_parent_order_idx")
  @@map("folders")
}

model Material {
  id          String     @id @default(cuid())
  title       String
  filename    String     // Original filename
  filePath    String     @map("file_path") // Path on disk or S3 key
  mimeType    String?    @map("mime_type")
  size        Int        // File size in bytes
  duration    Float?     // Duration in seconds
  
  folderId    String?    @map("folder_id")
  folder      Folder?    @relation(fields: [folderId], references: [id])
  userId      String     @map("user_id")
  user        User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  sentences   Sentence[]
  isProcessed Boolean    @default(false) @map("is_processed") // True if Whisper has finished
  
  // Transcription settings - records how this material was transcribed
  transcriptionEngine String? @map("transcription_engine") // "faster-whisper" or "openai-whisper"
  transcriptionModel String? @map("transcription_model") // Model name (tiny, base, small, etc.)
  transcriptionLanguage String? @map("transcription_language") // Detected or specified language
  transcriptionVadFilter Boolean? @map("transcription_vad_filter") // Whether VAD filter was used
  transcriptionComputeType String? @map("transcription_compute_type") // Compute type used
  transcriptionTime Float? @map("transcription_time") // Duration in seconds
  
  vocabExtractionTime Float? @map("vocab_extraction_time") // Duration in seconds for vocabulary extraction
  createdAt   DateTime   @default(now()) @map("created_at") @db.Timestamptz
  updatedAt   DateTime   @updatedAt @map("updated_at") @db.Timestamptz
  deletedAt   DateTime?  @map("deleted_at") @db.Timestamptz

  @@map("materials")
}

model Sentence {
  id          String   @id @default(cuid())
  materialId  String   @map("material_id")
  material    Material @relation(fields: [materialId], references: [id], onDelete: Cascade)
  
  startTime   Float    @map("start_time")
  endTime     Float    @map("end_time")
  content     String
  editedContent String? @map("edited_content")
  deletedAt   DateTime? @map("deleted_at") @db.Timestamptz
  createdAt   DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt   DateTime  @updatedAt @map("updated_at") @db.Timestamptz
  
  occurrences WordOccurrence[]
  practices   PracticeProgress[]
  
  order       Int      // To keep sentences in order

  @@map("sentences")
}

model Word {
  id          String           @id @default(cuid())
  text        String           @unique // Normalized text (lowercase, stemmed maybe)
  language    String           @default("en")
  phonetic    String?
  pos         String?
  translation String?
  definition  String?
  collins     Int?
  oxford      Int?
  tag         String?
  bnc         Int?
  frq         Int?
  exchange    String?
  audio       String?
  detail      String?          // JSON string or plain text detail
  deletedAt   DateTime? @map("deleted_at") @db.Timestamptz

  occurrences WordOccurrence[]
  statuses    UserWordStatus[]

  @@map("words")
}

model WordOccurrence {
  id          String   @id @default(cuid())
  wordId      String   @map("word_id")
  word        Word     @relation(fields: [wordId], references: [id])
  sentenceId  String   @map("sentence_id")
  sentence    Sentence @relation(fields: [sentenceId], references: [id], onDelete: Cascade)
  
  // Position in the sentence string (optional, for highlighting)
  startIndex  Int?     @map("start_index")
  endIndex    Int?     @map("end_index")

  @@map("word_occurrences")
}

model UserWordStatus {
  id        String     @id @default(cuid())
  userId    String     @map("user_id")
  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  wordId    String     @map("word_id")
  word      Word       @relation(fields: [wordId], references: [id], onDelete: Cascade)
  
  status    String     @default("UNKNOWN")
  
  // FSRS fields for spaced repetition
  fsrsDue         DateTime?  @map("fsrs_due") @db.Timestamptz
  fsrsStability   Float?     @map("fsrs_stability")
  fsrsDifficulty  Float?     @map("fsrs_difficulty")
  fsrsElapsedDays Int        @default(0) @map("fsrs_elapsed_days")
  fsrsScheduledDays Int      @default(0) @map("fsrs_scheduled_days")
  fsrsReps        Int        @default(0) @map("fsrs_reps")
  fsrsLapses      Int        @default(0) @map("fsrs_lapses")
  fsrsState       Int        @default(0) @map("fsrs_state") // 0=New, 1=Learning, 2=Review, 3=Relearning
  fsrsLastReview  DateTime?  @map("fsrs_last_review") @db.Timestamptz
  
  // Error tracking
  errorCount      Int        @default(0) @map("error_count")
  lastErrorAt     DateTime?  @map("last_error_at") @db.Timestamptz
  
  createdAt DateTime   @default(now()) @map("created_at") @db.Timestamptz
  updatedAt DateTime   @updatedAt @map("updated_at") @db.Timestamptz
  
  reviews   WordReview[]

  @@unique([userId, wordId])
  @@index([userId, status])
  @@index([userId, fsrsDue])
  @@map("user_word_statuses")
}

model WordReview {
  id              String   @id @default(cuid())
  userWordStatusId String  @map("user_word_status_id")
  userWordStatus  UserWordStatus @relation(fields: [userWordStatusId], references: [id], onDelete: Cascade)
  
  rating          Int      // FSRS rating 1-4 (Again, Hard, Good, Easy)
  mode            String   // "typing" or "multiple_choice"
  responseTimeMs  Int      @map("response_time_ms")
  wasCorrect      Boolean  @map("was_correct")
  errorCount      Int      @default(0) @map("error_count")
  
  // FSRS state after this review
  newStability    Float    @map("new_stability")
  newDifficulty   Float    @map("new_difficulty")
  newDue          DateTime @map("new_due") @db.Timestamptz
  
  createdAt       DateTime @default(now()) @map("created_at") @db.Timestamptz

  @@index([userWordStatusId])
  @@map("word_reviews")
}

model PracticeProgress {
  id          String   @id @default(cuid())
  userId      String   @map("user_id")
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  sentenceId  String   @map("sentence_id")
  sentence    Sentence @relation(fields: [sentenceId], references: [id], onDelete: Cascade)
  
  score       Int      // 0-100
  attempts    Int      @default(1)
  duration    Int      @default(0) // Duration in seconds
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt   DateTime @updatedAt @map("updated_at") @db.Timestamptz

  @@unique([userId, sentenceId])
  @@map("practice_progress")
}

model DailyStudyStat {
  id             String   @id @default(cuid())
  userId         String   @map("user_id")
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  date           DateTime @default(now()) @db.Timestamptz // We will typically store just the date part or normalize to midnight
  
  studyDuration  Int      @default(0) @map("study_duration") // Seconds spent practicing
  wordsAdded     Int      @default(0) @map("words_added")
  sentencesAdded Int      @default(0) @map("sentences_added")
  
  createdAt      DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt      DateTime @updatedAt @map("updated_at") @db.Timestamptz

  @@unique([userId, date]) // One entry per user per day
  @@map("daily_study_stats")
}

model Notification {
  id          String   @id @default(cuid())
  userId      String   @map("user_id")
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  type        String   // MATERIAL_UPLOADED, MATERIAL_PROCESSED, VOCAB_EXTRACTED, PRACTICE_MILESTONE, SYSTEM
  title       String
  message     String
  isRead      Boolean  @default(false) @map("is_read")
  
  // Optional reference to related entity
  relatedId   String?  @map("related_id") // Could be materialId, etc.
  relatedType String?  @map("related_type") // "material", "word", etc.
  
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz

  @@index([userId, isRead])
  @@index([userId, createdAt])
  @@map("notifications")
}

// Learning session tracking - records each learning session with timestamps
model LearningSession {
  id          String   @id @default(cuid())
  userId      String   @map("user_id")
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  sessionType String   @map("session_type") // "WORD" or "SENTENCE"
  startedAt   DateTime @map("started_at") @db.Timestamptz
  endedAt     DateTime? @map("ended_at") @db.Timestamptz
  
  // What was being studied
  materialId  String?  @map("material_id") // Optional - the material being studied
  
  // Progress tracking
  itemsStudied    Int   @default(0) @map("items_studied") // Number of words/sentences studied
  correctCount    Int   @default(0) @map("correct_count")
  incorrectCount  Int   @default(0) @map("incorrect_count")
  
  // Last studied item for "continue where you left off"
  lastItemId      String?  @map("last_item_id") // wordId or sentenceId
  lastItemType    String?  @map("last_item_type") // "word" or "sentence"
  
  createdAt   DateTime @default(now()) @map("created_at") @db.Timestamptz
  updatedAt   DateTime @updatedAt @map("updated_at") @db.Timestamptz

  @@index([userId, sessionType])
  @@index([userId, startedAt])
  @@map("learning_sessions")
}
